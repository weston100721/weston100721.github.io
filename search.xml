<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MYSQL建索引]]></title>
    <url>%2F2018%2F07%2F02%2FMYSQL%E5%BB%BA%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[本文主要讲述了如何加速动态网站的MySQL索引分析和优化。 一、什么是索引？ 索引用来快速地寻找那些具有特定值的记录，所有MySQL索引都以B-树的形式保存。如果没有索引，执行查询时MySQL必须从第一个记录开始扫描整个表的所有记录，直至找到符合要求的记录。表里面的记录数量越多，这个操作的代价就越高。如果作为搜索条件的列上已经创建了索引，MySQL无需扫描任何记录即可迅速得到目标记录所在的位置。如果表有1000个记录，通过索引查找记录至少要比顺序扫描记录快100倍。 假设我们创建了一个名为people的表： 1CREATE TABLE people ( peopleid SMALLINT NOT NULL, name CHAR(50) NOT NULL ); 然后，我们完全随机把1000个不同name值插入到people表。在数据文件中name列没有任何明确的次序。如果我们创建了name列的索引，MySQL将在索引中排序name列,对于索引中的每一项，MySQL在内部为它保存一个数据文件中实际记录所在位置的“指针”。因此，如果我们要查找name等于“Mike”记录的peopleidSQL命令为 SELECT peopleid FROM people WHERE name=&#39;Mike&#39;;，MySQL能够在name的索引中查找Mike值，然后直接转到数据文件中相应的行，准确地返回该行的peopleid（999）。在这个过程中，MySQL只需处理一个行就可以返回结果。如果没有name列的索引，MySQL要扫描数据文件中的所有记录，即1000个记录！显然，需要MySQL处理的记录数量越少，则它完成任务的速度就越快。 二、索引的类型MySQL提供多种索引类型供选择: 普通索引这是最基本的索引类型，而且它没有唯一性之类的限制。普通索引可以通过以下几种方式创建： 创建索引1CREATE INDEX &lt;索引的名字&gt; ON tablename (列的列表); 修改表1ALTER TABLE tablename ADD INDEX [索引的名字] (列的列表)； 查询索引1SHOW INDEX FROM t_work_sheet; 创建表的时候指定索引1CREATE TABLE tablename ( [...], INDEX [索引的名字] (列的列表) )； 唯一性索引:这种索引和前面的“普通索引”基本相同，但有一个区别：索引列的所有值都只能出现一次，即必须唯一。唯一性索引可以用以下几种方式创建： 创建索引，例如1CREATE UNIQUE INDEX &lt;索引的名字&gt; ON tablename (列的列表)； 修改表，例如1ALTER TABLE tablename ADD UNIQUE [索引的名字] (列的列表)； 创建表的时候指定索引，例如1CREATE TABLE tablename ( [...], UNIQUE [索引的名字] (列的列表) )； 主键主键是一种唯一性索引，但它必须指定为PRIMARY KEY。如果你曾经用过AUTO_INCREMENT类型的列，你可能已经熟悉主键之类的概念了。主键一般在创建表的时候指定，例如CREATE TABLE tablename ( [...], PRIMARY KEY (列的列表) ); ”。但是，我们也可以通过修改表的方式加入主键，例如ALTER TABLE tablename ADD PRIMARY KEY (列的列表);。每个表只能有一个主键。 全文索引:MySQL从3.23.23版开始支持全文索引和全文检索。在MySQL中，全文索引的索引类型为FULLTEXT。全文索引可以在VARCHAR或者TEXT类型的列上创建。它可以通过CREATE TABLE命令创建，也可以通过ALTER TABLE或CREATE INDEX命令创建。对于大规模的数据集，通过ALTER TABLE（或者CREATE INDEX）命令创建全文索引要比把记录插入带有全文索引的空表更快。本文下面的讨论不再涉及全文索引，要了解更多信息，请参见MySQL documentation。 三、单列索引与多列索引索引可以是单列索引，也可以是多列索引。下面我们通过具体的例子来说明这两种索引的区别。假设有这样一个people表： 123456CREATE TABLE people ( peopleid SMALLINT NOT NULL AUTO_INCREMENT,firstname CHAR(50) NOT NULL,lastname CHAR(50) NOT NULL,age SMALLINT NOT NULL,townid SMALLINT NOT NULL, PRIMARY KEY (peopleid) ); 下面是我们插入到这个people表的数据： 这个数据片段中有四个名字为“Mikes”的人（其中两个姓Sullivans，两个姓McConnells），有两个年龄为17岁的人，还有一个名字与众不同的Joe Smith。 这个表的主要用途是根据指定的用户姓、名以及年龄返回相应的peopleid。例如，我们可能需要查找姓名为Mike Sullivan、年龄17岁用户的peopleid（SQL命令为SELECT peopleid FROM people WHERE firstname=&#39;Mike&#39; AND lastname=&#39;Sullivan&#39; AND age=17；）。由于我们不想让MySQL每次执行查询就去扫描整个表，这里需要考虑运用索引。 首先，我们可以考虑在单个列上创建索引，比如firstname、lastname或者age列。如果我们创建firstname列的索引ALTER TABLE people ADD INDEX firstname (firstname)；，MySQL将通过这个索引迅速把搜索范围限制到那些firstname=’Mike’的记录，然后再在这个“中间结果集”上进行其他条件的搜索：它首先排除那些lastname不等于“Sullivan”的记录，然后排除那些age不等于17的记录。当记录满足所有搜索条件之后，MySQL就返回最终的搜索结果。 由于建立了firstname列的索引，与执行表的完全扫描相比，MySQL的效率提高了很多，但我们要求MySQL扫描的记录数量仍旧远远超过了实际所需要的。虽然我们可以删除firstname列上的索引，再创建lastname或者age列的索引，但总地看来，不论在哪个列上创建索引搜索效率仍旧相似。 为了提高搜索效率，我们需要考虑运用多列索引。如果为firstname、lastname和age这三个列创建一个多列索引，MySQL只需一次检索就能够找出正确的结果！下面是创建这个多列索引的SQL命令：ALTER TABLE people ADD INDEX fname_lname_age (firstname,lastname,age)； 由于索引文件以B树格式保存，MySQL能够立即转到合适的firstname，然后再转到合适的lastname，最后转到合适的age。在没有扫描数据文件任何一个记录的情况下，MySQL就正确地找出了搜索的目标记录！ 那么，如果在firstname、lastname、age这三个列上分别创建单列索引，效果是否和创建一个firstname、lastname、age的多列索引一样呢？答案是否定的，两者完全不同。当我们执行查询的时候，MySQL只能使用一个索引。如果你有三个单列的索引，MySQL会试图选择一个限制最严格的索引。但是，即使是限制最严格的单列索引，它的限制能力也肯定远远低于firstname、lastname、age这三个列上的多列索引。 四、最左前缀多列索引还有另外一个优点，它通过称为最左前缀（Leftmost Prefixing）的概念体现出来。继续考虑前面的例子，现在我们有一个firstname、lastname、age列上的多列索引，我们称这个索引为fname_lname_age。当搜索条件是以下各种列的组合时，MySQL将使用fname_lname_age索引： 123firstname，lastname，agefirstname，lastnamefirstname 从另一方面理解，它相当于我们创建了(firstname，lastname，age)、(firstname，lastname)以及(firstname)这些列组合上的索引。下面这些查询都能够使用这个fname_lname_age索引：123SELECT peopleid FROM people WHERE firstname=&apos;Mike&apos; AND lastname=&apos;Sullivan&apos; AND age=&apos;17&apos;;SELECT peopleid FROM people WHERE firstname=&apos;Mike&apos; AND lastname=&apos;Sullivan&apos;;SELECT peopleid FROM people WHERE firstname=&apos;Mike&apos;; The following queries cannot use the index at all: SELECT peopleid FROM people WHERE lastname=’Sullivan’;SELECT peopleid FROM people WHERE age=’17’;SELECT peopleid FROM people WHERE lastname=’Sullivan’ AND age=’17’;]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BitSet]]></title>
    <url>%2F2017%2F07%2F03%2FBitSet%2F</url>
    <content type="text"><![CDATA[听说百度曾经出过这样一道题： 有一千万个随机数，每个随机数的范围在0到1亿之间，现在要求写出一种算法，将1到1亿之间没有在随机数中的数求出来？ 我们先不管百度有没有出过这样的面试题，反正我是在网上看到的。对于这个问题，如果不考虑性能和内存问题，那逻辑非常简单。反之，就需要用到今天介绍的java.util.BitSet。 BitSet 介绍该类实现了一个按需增长的位向量。每个bit值为一个布尔值(true/false)，用非负的整数将BitSet的每个bit位编入索引。可以对每个编入索引的位进行测试、设置或者清除。通过逻辑与、逻辑或和逻辑异或操作，可以使用一个BitSet修改另一个BitSet的内容。BitSet不是线程安全的。 基本原理先用伪代码来举个例子：假设有这样一种类型bit，那么8个bit占用一个字节。现在我们要存储(1, 4, 5，7)这四个int类型的数，那么我们需要 4 * 8字节。但是可以bit的方式，伪代码如下：12345678910111213141516bit[] store = new bit[7+1]; // (1)bit[1] = 1;bit[4] = 1;bit[5] = 1;bit[7] = 1;// 获取public List&lt;Integer&gt; getResult()&#123; List&lt;Integer&gt; result = new ArrayList(); for(int i = 0; i &lt;= store.length; i++)&#123; if(bit[i] == 1)&#123; result.add(i); &#125; &#125; return result;&#125; 上面步骤(1)中存储四个数仅用了一个字节，使用的内存是原来 1/32。然而，在Java语言中并没有这种类型，但是java.util.BitSet却使用long型完成了同样的事情。 BitSet源码分析BitSet真正存储数据的地方：1234/** * The internal field corresponding to the serialField "bits". */private long[] words; 一个long型的数据占八个字节，共64位。所以当long[] words的长度为1时，只能存储的最大数为63；为2时，只能存储的最大数为127；以此类推。所以你就能明白以下代码：123private final static int ADDRESS_BITS_PER_WORD = 6;private final static int BITS_PER_WORD = 1 &lt;&lt; ADDRESS_BITS_PER_WORD;private final static int BIT_INDEX_MASK = BITS_PER_WORD - 1; 创建一个BitSet的默认大小为一个long[] words = new long[1]，也就是说只能存0到63。1234567/** * Creates a new bit set. All bits are initially &#123;@code false&#125;. */public BitSet() &#123; initWords(64); sizeIsSticky = false;&#125; 当然如果存64也不会报错，如果容量不够会自动进行扩展，扩展时容量翻倍：12345678private void ensureCapacity(int wordsRequired) &#123; if (words.length &lt; wordsRequired) &#123; // Allocate larger of doubled size or required size int request = Math.max(2 * words.length, wordsRequired); words = Arrays.copyOf(words, request); sizeIsSticky = false; &#125;&#125; 存储一个数时，将对应的索引位置1，使用set方法：1234567891011public void set(int bitIndex) &#123; if (bitIndex &lt; 0) throw new IndexOutOfBoundsException("bitIndex &lt; 0: " + bitIndex); int wordIndex = wordIndex(bitIndex); expandTo(wordIndex); words[wordIndex] |= (1L &lt;&lt; bitIndex); // Restores invariants checkInvariants();&#125; BitSet还提供了一些好用的方法： 与、或、异或的操作。 提供BitSet对象持久化读写的操作。 提供一个stream()方法，方便函数式编程。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
        <tag>java</tag>
        <tag>BitSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Base64]]></title>
    <url>%2F2017%2F07%2F01%2FBase64%2F</url>
    <content type="text"><![CDATA[Base64是种编码和解码的规则，用64个字符来表示任意二进制数据的方法。将ASCII码中可见字符、不可见字符及控制字符等编码成可见字符。在网络上交换数据时，数据往往要经过多个路由设备，由于不同的设备对字符的处理方式有一些不同，这样那些不可见字符就有可能被处理错误，不利于传输。根证书，一般都是作Base64编码的，因为它要在网上被许多人下载。电子邮件的附件一般也作Base64编码的，因为一个附件数据往往是有不可见字符的。数据传递时有时采用json格式，当需要传递二进制数据（图片、PDF等）时，也可以用到。 编码原理准备一个包含64个字符的数组：12345678private static final char[] toBase64 = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'&#125;; 由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种 url safe 的base64编码，其实就是把字符+和/分别变成-和_： 1234567private static final char[] toBase64URL = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'&#125;; 编码 对二进制数据进行处理，每3个字节一组，一共是3x8=24bit： 1234567812345678123456788 bit8 bit8 bit6 bit6 bit6 bit6 bit 如果最末尾一组不足三个字节，最后会剩下1个或2个字节怎么办？Base64用\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。 然后将每个bit组（6 bit）转化为对应的字符，对应的字符值可依据下表： 举例字节数是三的倍数，如字符串zlk，Base64编码后为emxr，其转化流程如下： zlk01111010011011000110101101111010011011000110101101111010011011000110101130384943emxr 字节数不是三的倍数，如字符zl，Base64编码后为emw=，其转化流程如下： zl01111010011011000111101001101100xxxxxxxx0111101001101100xxxxxxxx011110100110110000xxxxxx303848=emw=]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
        <tag>Base64</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK之java.util.Objects]]></title>
    <url>%2F2017%2F06%2F30%2FJDK%E4%B9%8Bjava-util-Objects%2F</url>
    <content type="text"><![CDATA[在编码时我们经常会遇到是否为空的判断，例如：if (xxx == null) { ... } else { ... }等，许多人会用一些第三方的工具包如commons-lang，guava中的工具类来替代这种冗余的写法，殊不知，JDK中就有提供对null处理的很好的工具类 java.util.Objects。在我看来， 在相同的工作量和差不多的性能的情况下，优先考虑JDK中自带的类。 java.util.Objects简介此类提供了一些操作对象的静态工具方法。包括空指针安全和空指针容忍的工具方法，用于计算对象哈希值，为对象返回字符串及比较两个对象。 对于null的处理对于null的处理，提供了以下5个方法，能满足你大部分对null的判断和处理。 12345678910111213141516171819202122232425public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj; &#125; public static &lt;T&gt; T requireNonNull(T obj, String message) &#123; if (obj == null) throw new NullPointerException(message); return obj; &#125; public static boolean isNull(Object obj) &#123; return obj == null; &#125; public static boolean nonNull(Object obj) &#123; return obj != null; &#125; public static &lt;T&gt; T requireNonNull(T obj, Supplier&lt;String&gt; messageSupplier) &#123; if (obj == null) throw new NullPointerException(messageSupplier.get()); return obj; &#125; 代码值得学习之处final类定义Objects为final类：public final class Objects{ ... }。如果你认为一个类包括对某种事物处理的全部方法并不允许被继承，那就应该使用。 不允许构建实例对象123private Objects() &#123; throw new AssertionError("No java.util.Objects instances for you!");&#125; 所以你以后写一个工具类，并不允许实例，就可以就构造方法设置私有，并在构造方法中抛出异常。按上述代码依葫芦画瓢就是了。 泛型多在自己写的代码中使用泛型，增加代码的通用性，提高被重复使用的使用率。类中的例子参考：12345public static &lt;T&gt; T requireNonNull(T obj) &#123; if (obj == null) throw new NullPointerException(); return obj;&#125;]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码之UUID]]></title>
    <url>%2F2017%2F06%2F29%2FJDK%E6%BA%90%E7%A0%81%E4%B9%8BUUID%2F</url>
    <content type="text"><![CDATA[UUID(univerally unique identifier),通用唯一识别码，最开始使用于阿波罗网络计算系统，软件开放组织用于DCE(distributed computing environment),后来微软用于windows平台上。UUID为固定长度128位，与其他替代品相比，这已经算是相当小的。这便于排序，存储和分配等。而其他重要的应用，则有 Linux ext2/ext3 档案系统、LUKS 加密分割区、GNOME、KDE、Mac OS X 等等。 UUID结构组成 当前日期和时间。 时钟序列。 全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得 UUID time-low “-“ time-mid “-“ time-high-and-version “-“ clock-seq-and-reserved clock-seq-low “-“ node time-low 4hexOctet time-mid 2hexOctet time-high-and-version 2hexOctet clock-seq-and-reserved hexOctet clock-seq-low hexOctet node 6hexOctet hexOctet hexDigit hexDigit hexDigit 0~9,’a’~’f’,’A’~’F’ 举个例子：f81d4fae-7dec-11d0-a765-00a0c91e6bf6 12345678910110 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| time_low |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| time_mid | time_hi_and_version |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|clk_seq_hi_res | clk_seq_low | node (0-1) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| node (2-5) |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ versionVersion 1：基于时间的UUID(The time-based version)基于时间的UUID通过计算当前时间戳、随机数和机器MAC地址得到。由于在算法中使用了MAC地址，这个版本的UUID可以保证在全球范围的唯一性。但与此同时，使用MAC地址会带来安全性问题，这就是这个版本UUID受到批评的地方。如果应用只是在局域网中使用，也可以使用退化的算法，以IP地址来代替MAC地址－－Java的UUID往往是这样实现的（当然也考虑了获取MAC的难度）。 Version 2：DCE安全的UUID(DCE Security version, with embedded POSIX UIDs.)分布式计算环境（Distributed Computing Environment)安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。 Version 3：基于名字的UUID（MD5）基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。 Version 4：随机UUID根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但随机的东西就像是买彩票：你指望它发财是不可能的，但狗屎运通常会在不经意中到来。 Version 5：基于名字的UUID（SHA1和版本3的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。 java.util.UUID 表示通用唯一标识符 (UUID) 的类。 UUID 表示一个 128 位的值。这些通用标识符具有不同的变体。此类的方法用于操作 Leach-Salz 变体，不过构造方法允许创建任何 UUID 变体 变体 2 (Leach-Salz) UUID 的布局如下： long 型数据的最高有效位由以下无符号字段组成： 0xFFFFFFFF00000000 time_low 0x00000000FFFF0000 time_mid 0x000000000000F000 version 0x0000000000000FFF time_hi long 型数据的最低有效位由以下无符号字段组成： 0xC000000000000000 variant 0x3FFF000000000000 clock_seq 0x0000FFFFFFFFFFFF node 参考文献 UUID rfc4122]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>JDK源码</tag>
        <tag>java</tag>
        <tag>UUID</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant配置]]></title>
    <url>%2F2017%2F04%2F05%2Fvagrant%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[The primary function of the Vagrantfile is to describe the type of machine required for a project, and how to configure and provision these machines. Vagrantfiles are called Vagrantfiles because the actual literal filename for the file is Vagrantfile (casing does not matter unless your file system is running in a strict case sensitive mode). Vagrant is meant to run with one Vagrantfile per project, and the Vagrantfile is supposed to be committed to version control. This allows other developers involved in the project to check out the code, run vagrant up, and be on their way. Vagrantfiles are portable across every platform Vagrant supports. The syntax of Vagrantfiles is Ruby, but knowledge of the Ruby programming language is not necessary to make modifications to the Vagrantfile, since it is mostly simple variable assignment. In fact, Ruby is not even the most popular community Vagrant is used within, which should help show you that despite not having Ruby knowledge, people are very successful with Vagrant. Vagrantfile1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# -*- mode: ruby -*-# vi: set ft=ruby :# All Vagrant configuration is done below. The "2" in Vagrant.configure# configures the configuration version (we support older styles for# backwards compatibility). Please don't change it unless you know what# you're doing.# 所有的vagrant配置在下面。在Vagrant.configure中的配置值“２”用于配置vagrant配置文件版本。（版本向下兼容）。不懂不要修改。Vagrant.configure("2") do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://atlas.hashicorp.com/search. # 每个vagrant开发环境都需要一个box。你可以在https://atlas.hashicorp.com/search中搜索你需要的box. # 以下是配置多个虚拟机： config.vm.define "vagrant1" do |vagrant1| vagrant1.vm.box = "centos/7" vagrant1.vm.network "forwarded_port", guest: 80, host: 8086 vagrant1.vm.network "forwarded_port", guest: 443, host: 8446 end config.vm.define "vagrant2" do |vagrant2| vagrant2.vm.box = "ubuntu/trusty64" vagrant2.vm.network "forwarded_port", guest: 80, host: 8087 vagrant2.vm.network "forwarded_port", guest: 443, host: 8447 end # Disable automatic box update checking. If you disable this, then # boxes will only be checked for updates when the user runs # `vagrant box outdated`. This is not recommended. config.vm.box_check_update = false # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine. In the example below, # accessing "localhost:8080" will access port 80 on the guest machine. # 较为常用是端口映射，就是将虚拟机中的端口映射到宿主机对应的端口直接使用 # guest: 80 表示虚拟机中的80端口， host: 8080 表示映射到宿主机的8080端口。 # config.vm.network "forwarded_port", guest: 80, host: 8080 # Create a private network, which allows host-only access to the machine # using a specific IP. # 如果需要自己自由的访问虚拟机，但是别人不需要访问虚拟机，可以使用private_network，并为虚拟机设置IP # 192.168.33.10 表示虚拟机的IP，多台虚拟机的话需要互相访问的话，设置在相同网段即可 # config.vm.network "private_network", ip: "192.168.33.10" # Create a public network, which generally matched to bridged network. # Bridged networks make the machine appear as another physical device on # your network. # 如果需要将虚拟机作为当前局域网中的一台计算机，由局域网进行DHCP # config.vm.network "public_network" # Share an additional folder to the guest VM. The first argument is # the path on the host to the actual folder. The second argument is # the path on the guest to mount the folder. And the optional third # argument is a set of non-required options. # 在虚拟机和宿主机之间建立一个共享的文件夹，此文件夹实时同步。 # config.vm.synced_folder "../data", "/vagrant_data" # Provider-specific configuration so you can fine-tune various # backing providers for Vagrant. These expose provider-specific options. # Example for VirtualBox: # # config.vm.provider "virtualbox" do |vb| # # Display the VirtualBox GUI when booting the machine # vb.gui = true # # # Customize the amount of memory on the VM: # vb.memory = "1024" # end # # View the documentation for the provider you are using for more # information on available options. # Define a Vagrant Push strategy for pushing to Atlas. Other push strategies # such as FTP and Heroku are also available. See the documentation at # https://docs.vagrantup.com/v2/push/atlas.html for more information. # config.push.define "atlas" do |push| # push.app = "YOUR_ATLAS_USERNAME/YOUR_APPLICATION_NAME" # end # Enable provisioning with a shell script. Additional provisioners such as # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the # documentation for more information about their specific syntax and use. # config.vm.provision "shell", inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2 # SHELLend 一些参考文档 Uninstalling Vagrant Vagrantfile路径查询 SSH Settings vagrant官方文档 vagrant的github]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>vagrant</tag>
        <tag>虚拟机</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible简记]]></title>
    <url>%2F2017%2F03%2F28%2Fansible%E7%AE%80%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ansible ansible是新出现的自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架。主要包括：(1)、连接插件connection plugins：负责和被监控端实现通信；(2)、host inventory：指定操作的主机，是一个配置文件里面定义监控的主机；(3)、各种模块核心模块、command模块、自定义模块；(4)、借助于插件完成记录日志邮件等功能；(5)、playbook：剧本执行多个任务时，非必需可以让节点一次性运行多个任务。 注意：windows不能作为控制机 安装12sudo pip install ansiblesudo yum install ansible 测试12ansible all -m pingansible host -i hosts -m ping 执行的hosts可以通过外部变量传递12ansible-playbook extraHost.yml --extra-vars &quot;@hosts.yml&quot;ansible-playbook extraHost.yml --extra-vars &quot;@hosts.json&quot; 下载文件 1ansible-playbook download.yml ad-Hoc An ad-hoc command is something that you might type in to do something really quick, but don’t want to save for later.This is a good place to start to understand the basics of what Ansible can do prior to learning the playbooks language – ad-hoc commands can also be used to do quick things that you might not necessarily want to write a full playbook for.Generally speaking, the true power of Ansible lies in playbooks. Why would you use ad-hoc tasks versus playbooks?For instance, if you wanted to power off all of your lab for Christmas vacation, you could execute a quick one-liner in Ansible without writing a playbook.For configuration management and deployments, though, you’ll want to pick up on using ‘/usr/bin/ansible-playbook’ – the concepts you will learn here will port over directly to the playbook language.指的是使用 /usr/bin/ansible命令运行Ansible直接执行一些命令，而不是使用 /usr/bin/ansible-playbook执行剧本。一个ad-hoc命令例子，可以是在你的基础设施里面重启10台机器。任何你可以做的东西， ad-hoc 都可以实现通过写一个剧本, 剧本肯定也组合了其它的一些操作。 Parallelism and Shell Commands12345ansible atlanta -a "/sbin/reboot" -f 10ansible atlanta -a "/usr/bin/foo" -u usernameansible atlanta -a "/usr/bin/foo" -u username --become [--ask-become-pass]ansible atlanta -a "/usr/bin/foo" -u username --become-user otheruser [--ask-become-pass]ansible raleigh -m shell -a 'echo $TERM' File Transfer12345ansible atlanta -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts&quot;ansible webservers -m file -a &quot;dest=/srv/foo/a.txt mode=600&quot;ansible webservers -m file -a &quot;dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan&quot;ansible webservers -m file -a &quot;dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory&quot;ansible webservers -m file -a &quot;dest=/path/to/c state=absent&quot; Managing Packages1234ansible webservers -m yum -a &quot;name=acme state=present&quot;ansible webservers -m yum -a &quot;name=acme-1.5 state=present&quot;ansible webservers -m yum -a &quot;name=acme state=latest&quot;ansible webservers -m yum -a &quot;name=acme state=absent&quot; Users and Groups12ansible all -m user -a &quot;name=foo password=&lt;crypted password here&gt;&quot;ansible all -m user -a &quot;name=foo state=absent&quot; Deploying From Source Control1ansible webservers -m git -a &quot;repo=git://foo.example.org/repo.git dest=/srv/myapp version=HEAD&quot; managing services123ansible webservers -m service -a &quot;name=httpd state=started&quot;ansible webservers -m service -a &quot;name=httpd state=restarted&quot;ansible webservers -m service -a &quot;name=httpd state=stopped&quot; Time Limited Background Operations123ansible all -B 3600 -P 0 -a &quot;/usr/bin/long_running_operation --do-stuff&quot;ansible web1.example.com -m async_status -a &quot;jid=488359678239.2844&quot;ansible all -B 1800 -P 60 -a &quot;/usr/bin/long_running_operation --do-stuff&quot; Gathering Facts1ansible all -m setup ansible.cfg配置文件ansible.cfg的读取顺序： ANSIBLE_CONFIG环境变量所指的位置 当前目录的ansible.cfg ~/.ansible.cfg(用户目录下的ansible.cfg) /etc/ansible/ansible.cfg 建议： 将ansible.cfg与playbooks一起放在当前目录。 模块 apt copy file service template 可以通过ansible-doc file来了解file模块，其他类似。还可以通过模块索引找到自己想要的模块。ansible支持的模块的源码在github上。 inventory 名称 默认值 描述 ansible_ssh_host 主机名字 将要连接的远程主机名,与你想要设定的主机的别名不同的话,可通过此变量设置. ansible_ssh_port 22 ssh端口号.如果不是默认的端口号,通过此变量设置. ansible_ssh_user root ansible_ssh_pass none 密码(这种方式并不安全,我们强烈建议使用 –ask-pass 或 SSH 密钥) ansible_sudo_pass none 密码(这种方式并不安全,我们强烈建议使用 –ask-sudo-pass) ansible_connection smart 与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 ‘smart’,’smart’ 方式会根据是否支持 ControlPersist, 来判断’ssh’ 方式是否可行. ansible_ssh_private_key_file none ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况. ansible_shell_type sh 目标系统的shell类型.默认情况下,命令的执行使用 ‘sh’ 语法,可设置为 ‘csh’ 或 ‘fish’. ansible_python_interpreter /usr/bin/python python的解释器 ansible_*_interpreter none 类似python的解释器一样，根据其语言而定 变量查看变量123ansible all -m setupansible all -m setup -a 'filter=ansible_eth*'- debug: var=myvarname 变量注册12345- name: capture output of whoami command command: whoami register: login ignore_errors: True # 出错就会终止，但是有了这个配置就可以解决这个问题。- debug: var=&quot;user is &#123;&#123; login.stdout &#125;&#125;&quot; 访问变量中字典的key1234ansible_eth1[&apos;ipv4&apos;][&apos;address&apos;]ansible_eth1[&apos;ipv4&apos;].addressansible_eth1.ipv4[&apos;address&apos;]ansible_eth1.ipv4.address fact查看fact子集1ansible all -m setup -a &apos;filter=ansible_eth*&apos; 本地fact将多个文件放置在/etc/ansible/facts.d/目录下，支持一下几种格式： .ini格式 JSON格式 以这种方式加载的fact是key为ansible_local的特殊变量。 变量优先级 ansible-playbook -i hostsforvar getvar.yml –extra-vars “test_vars=line” roles/xxx/var/main.yml playbook中的vars host_vars/hostname.yml中的变量 group_vars/中的变量 roles/xxx/defaults/main.yml 中的变量。 extra-vars的外部变量的传递语法额外的变量设置为键=值、YAML 或 JSON，例如--extra-vars &quot;@some_file.json&quot;1234--extra-vars &quot;test_vars=line&quot;--extra-vars &apos;&#123;&quot;pacman&quot;:&quot;mrs&quot;,&quot;ghosts&quot;:[&quot;inky&quot;,&quot;pinky&quot;,&quot;clyde&quot;,&quot;sue&quot;]&#125;&apos;--extra-vars &quot;@some_file.json&quot;--extra-vars &quot;@some_file.yml&quot; 注意： 不能混合传递，例如--extra-vars &quot;test_vars=line @some_file.yml&quot; rolesrole的优先级 与playbook并列的roles目录。 /etc/ansible/roles。 ansible.cfg中指定的位置，如下所示。 12[defaults]roles_path = ~/ansible_roles 可以通过ANSIBLE_ROLES_PATH环境变量来覆盖这个设置。 新建一个role1ansible-galaxy init --offline roles/&#123;&#123; name &#125;&#125; 测试环境搭建安装vagrant_1.9.1_x86_64.deb和virtualbox-5.1_5.1.12-112440-Ubuntu-xenial_amd64.deb具体安装过程可以参考vagrantup 和virtualbox官网。 12vagrant init ubuntu/trusty64vagrant up Vagrantfile文件配置： 12345678910111213141516171819202122232425Vagrant.configure(&quot;2&quot;) do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://atlas.hashicorp.com/search. # config.vm.box = &quot;ubuntu/trusty64&quot; config.ssh.insert_key = false config.vm.define &quot;vagrant1&quot; do |vagrant1| vagrant1.vm.box = &quot;ubuntu/trusty64&quot; vagrant1.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080 vagrant1.vm.network &quot;forwarded_port&quot;, guest: 443, host: 8443 end config.vm.define &quot;vagrant2&quot; do |vagrant2| vagrant2.vm.box = &quot;ubuntu/trusty64&quot; vagrant2.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8081 vagrant2.vm.network &quot;forwarded_port&quot;, guest: 443, host: 8444 end config.vm.define &quot;vagrant3&quot; do |vagrant3| vagrant3.vm.box = &quot;ubuntu/trusty64&quot; vagrant3.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8082 vagrant3.vm.network &quot;forwarded_port&quot;, guest: 443, host: 8445 endend 参考文档 ansible官方中文文档 jinja2模板语法 开发者贡献的roles]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>ansible</tag>
        <tag>自动化部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2017%2F03%2F28%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[防火墙centos7 防火墙关闭12systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 在防火墙下开放某个端口12firewall-cmd --query-port=80/tcp # 如要查询是否开启80端口firewall-cmd --add-port=80/tcp # 开启80端口 ssh秘钥登录原理使用一种被称为”公私钥”认证的方式来进行ssh登录. “公私钥”认证方式简单的解释是 首先在客户端上创建一对公私钥 （公钥文件：~/.ssh/id_rsa.pub； 私钥文件：~/.ssh/id_rsa）。 然后把公钥放到服务器上（~/.ssh/authorized_keys）, 自己保留好私钥。 当ssh登录时，ssh程序会发送私钥去和服务器上的公钥做匹配，如果匹配成功就可以登录了。 秘钥生成12345678910111213141516171819202122$ ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key (/home/couchdb/.ssh/id_rsa):Created directory '/home/couchdb/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /home/couchdb/.ssh/id_rsa.Your public key has been saved in /home/couchdb/.ssh/id_rsa.pub.The key fingerprint is:SHA256:2RCzuHj/UdqNCc73+uIt8J2BhLjfynKEXuOIVIvAGqc couchdb@troy-Inspiron-3847The key's randomart image is:+---[RSA 2048]----+| o || . + || . . o. . || . +. .o+. . || =..ooS+o... || E .o.+o==.+. || . o.*===..o || . +o+o=oo || o+oo=+ |+----[SHA256]-----+ 把公钥放到服务器使用ssh username@192.168.1.1登录到服务器，编辑服务器上~/.ssh/authorized_keys文件，将客户端机器上的~/.ssh/id_rsa.pub文件内容追加到~/.ssh/authorized_keys文件中。可以在客户端机器上使用以下命令来实现：12cat ~/.ssh/id_rsa.pub | ssh username@192.168.1.1 "cat - &gt;&gt; ~/.ssh/authorized_keys"cat /root/.ssh/id_rsa.pub|ssh root@192.168.2.168 "cat - &gt;&gt; /root/.ssh/authorized_keys" 登录1ssh username@192.168.1.1]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashCode理解]]></title>
    <url>%2F2017%2F03%2F24%2FhashCode%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在Java的Object类中有一个方法: 1public native int hashCode(); 根据这个方法的声明可知，该方法返回一个int类型的数值，并且是本地方法，因此在Object类中并没有给出具体的实现。 native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。JNI是Java本机接口（Java Native Interface），是一个本机编程接口，它是Java软件开发工具箱（Java Software Development Kit，SDK）的一部分。JNI允许Java代码使用以其他语言编写的代码和代码库。Invocation API（JNI的一部分）可以用来将Java虚拟机（JVM）嵌入到本机应用程序中，从而允许程序员从本机代码内部调用Java代码。 hashCode方法的作用对于包含容器类型的程序设计语言来说，基本上都会涉及到hashCode。在Java中也一样，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。 为什么这么说呢？考虑一种情况，当向集合中插入对象时，如何判别在集合中是否已经存在该对象了？（注意：集合中不允许重复的元素存在） 也许大多数人都会想到调用equals方法来逐个进行比较，这个方法确实可行。但是如果集合中已经存在一万条数据或者更多的数据，如果采用equals方法去逐一比较，效率必然是一个问题。此时hashCode方法的作用就体现出来了，当集合要添加新的对象时，先调用这个对象的hashCode方法，得到对应的hashcode值，实际上在HashMap的具体实现中会用一个table保存已经存进去的对象的hashcode值，如果table中没有该hashcode值，它就可以直接存进去，不用再进行任何比较了；如果存在该hashcode值， 就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址，所以这里存在一个冲突解决的问题，这样一来实际调用equals方法的次数就大大降低了，说通俗一点：Java中的hashCode方法就是根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为散列值。 因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。 也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；如果两个对象的hashcode值相等，则equals方法得到的结果未知。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hashcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tinkerpop中对Traversal的理解]]></title>
    <url>%2F2017%2F03%2F23%2Ftinkerpop%E4%B8%AD%E5%AF%B9Traversal%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. TraversalSource a generator of traversals for a particular graph, domain specific language (DSL), and execution engine. Traversals in Gremlin are spawned from a TraversalSource. The GraphTraversalSource is the typical “graph-oriented” DSL used throughout the documentation and will most likely be the most used DSL in a TinkerPop application. A GraphTraversal&lt;S,E&gt; is spawned from a GraphTraversalSource. It can also be spawned anonymously (i.e. empty) via __. A graph traversal is composed of an ordered list of steps. All the steps provided by GraphTraversal inherit from the more general forms diagrammed above. A list of all the steps (and their descriptions) are provided in the TinkerPop3 GraphTraversal JavaDoc. The following subsections will demonstrate the GraphTraversal steps using the Gremlin Console. TraversalSource是一个接口，GraphTraversalSource是其中一个实现，也是“图导向”的DSL。 2. Traversal GraphTraversal&lt;S,E&gt;由GraphTraversalSource大量产生，也可以由__匿名产生。一个图遍历是由一个由step组成的有序列表构成。 在最一般的情况下，遍历就是Traversal&lt;S,E&gt;，它实现了Iterator&lt;E&gt;接口，其中S代表开始，E代表结束。一个遍历由以下四种组件组成： Step&lt;S,E&gt;：将S产生E的一个独立功能。一个遍历有多个step级联组成。（Steps are chained within a traversal.） TraversalStrategy：改变遍历执行的拦截方法。（例如：查询重写）。 TraversalSideEffects：用于存储关于遍历的全局信息的键值对。 Traverser&lt;T&gt;：在当前的Traversal中传播的对象，T代表处理的对象。 GraphTraversal&lt;S,E&gt;提供了一个图遍历的经典概念，它继承的Traversal&lt;S,E&gt;。提供了通过点、边等图术语对图数据的解释。 The underlying Step implementations provided by TinkerPop should encompass most of the functionality required by a DSL author. It is important that DSL authors leverage the provided steps as then the common optimization and decoration strategies can reason on the underlying traversal sequence. If new steps are introduced, then common traversal strategies may not function properly. Traverser&lt;T&gt;实现了Iterator&lt;E&gt;、Serializable、Cloneable。说明能迭代，是对Step迭代。能序列化，能复制。 Traverser&lt;T&gt;接口中包含有Admin&lt;S, E&gt;接口，此接口提供了一下一些接口。 3. TraverserTraverser&lt;T&gt;：在当前的Traversal中传播的对象，T代表处理的对象。 4. Step以下就是一个Traversal:1g.V(1).as(&apos;a&apos;).out(&apos;created&apos;).in(&apos;created&apos;).where(neq(&apos;a&apos;)).addE(&apos;co-developer&apos;).from(&apos;a&apos;).property(&apos;year&apos;,2009) 其中V(1)、as(&#39;a&#39;)、out(&#39;created&#39;)、in(&#39;created&#39;)、where(neq(&#39;a&#39;))、addE(&#39;co-developer&#39;)、from(&#39;a&#39;)、property(&#39;year&#39;,2009)、都是step。所以Traversal是一个由多个step组成的链。 step 分为以下5中类型： 5. DefaultGraphTraversalDefaultGraphTraversal继承DefaultTraversal，并实现了GraphTraversal.Admin&lt;S, E&gt;接口。DefaultTraversal实现Traversal接口。一个Traversal中包含的所有step都存放在DefaultTraversal中的protected List&lt;Step&gt; steps = new ArrayList&lt;&gt;();中，并提供了addStep(final int index, final Step&lt;?, ?&gt; step)和removeStep(final int index)方法。这两个方法都被Traversal中的addStep(final Step&lt;?, E2&gt; step)封装。每一个step中都维护一个id，此id由DefaultTraversal中的stepPosition来维护，它提供了nextXId()方法。TraverserGenerator generator是产生各种Traverser的生产器，系统还提供了DefaultTraverserGeneratorFactory，能根据Set&lt;TraverserRequirement&gt; requirements来产生相应的TraverserGenerator，采用工厂模式。]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>tinkerpop</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[couchdb集群搭建]]></title>
    <url>%2F2017%2F03%2F23%2Fcouchdb%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最近在搭建couchdb集群时，遇到不少坑，如果你参照官方文档搭建集群时会不成功，至少我是这样的。在这里以ubuntu 16.04配置couchdb集群为例，写个总结，以备遗忘。 环境安装其他环境的安装请参考windows，mac OS X. 123sudo apt-get --no-install-recommends -y install \ build-essential pkg-config erlang \ libicu-dev libmozjs185-dev libcurl4-openssl-dev 下载 apache-couchdb-2.0.0.tar.gz下载apache-couchdb-2.0.0.tar.gz并解压，解压后的目录COUCHDB_HOME 编译安装couchDB123 cd COUCHDB_HOME./configuremake release 安装成功后的couchdb发布在COUCHDB_HOME/rel/couchdb. 集群配置注意： 所有的集群节点设置为相同的用户名和密码。修改配置：COUCHDB_HOME/rel/couchdb/etc/local.ini为：12345[chttpd]bind_address = 0.0.0.0[admins]admin = password # 用户名和密码 修改配置：COUCHDB_HOME/rel/couchdb/etc/vm.agrs，假设本节点的ip为192.168.199.236，则修改为： 1-name couchdb@192.168.199.236 修改配置：COUCHDB_HOME/rel/couchdb/releases/2.0.0/sys.config为： 123456789101112131415161718192021[ &#123;lager, [ &#123;error_logger_hwm, 1000&#125;, &#123;error_logger_redirect, true&#125;, &#123;handlers, [ &#123;lager_console_backend, [debug, &#123; lager_default_formatter, [ date, &quot; &quot;, time, &quot; [&quot;, severity, &quot;] &quot;, node, &quot; &quot;, pid, &quot; &quot;, message, &quot;\n&quot; ] &#125;]&#125; ] &#125;, &#123;inet_dist_listen_min, 9100&#125;, &#123;inet_dist_listen_max, 9200&#125; ]&#125;]. 启动couchdb1COUCHDB_HOME/rel/couchdb/bin/couchdb 访问http://192.168.199.236:5984/，如返回：123456789&#123; couchdb: &quot;Welcome&quot;, version: &quot;2.0.0&quot;, vendor: &#123; name: &quot;The Apache Software Foundation&quot; &#125;&#125; 则表示启动成功。 集群节点添加如果添加192.168.199.189,在192.168.199.189上按照上述步骤走一遍，将ip更换为192.168.199.189即可。 在192.168.199.236节点上添加192.168.199.189节点：12345curl -X POST -H &quot;Content-Type: application/json&quot; http://admin:password@127.0.0.1:5984/_cluster_setup -d &apos;&#123;&quot;action&quot;: &quot;enable_cluster&quot;, &quot;bind_address&quot;:&quot;0.0.0.0&quot;, &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;:&quot;password&quot;, &quot;port&quot;: 5984, &quot;remote_node&quot;: &quot;192.168.199.189&quot;, &quot;remote_current_user&quot;: &quot;admin&quot;, &quot;remote_current_password&quot;: &quot;password&quot; &#125;&apos;curl -X POST -H &quot;Content-Type: application/json&quot; http://admin:password@127.0.0.1:5984/_cluster_setup -d &apos;&#123;&quot;action&quot;: &quot;add_node&quot;, &quot;host&quot;:&quot;192.168.199.189&quot;, &quot;port&quot;: &quot;5984&quot;, &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;:&quot;password&quot;&#125;&apos;curl -X POST -H &quot;Content-Type: application/json&quot; http://admin:password@127.0.0.1:5984/_cluster_setup -d &apos;&#123;&quot;action&quot;: &quot;finish_cluster&quot;&#125;&apos; 访问http://127.0.0.1:5984/_membership时能看到如下返回的数据：12345678910&#123;all_nodes: [ &quot;couchdb@192.168.199.189&quot;, &quot;couchdb@192.168.199.236&quot; ],cluster_nodes: [ &quot;couchdb@192.168.199.189&quot;, &quot;couchdb@192.168.199.236&quot; ]&#125; 这表示集群搭建成功。或如果在192.168.199.236上的couchdb中添加一个数据库表，如果能在192.168.199.189上的couchdb中看到，表示安装成功。```]]></content>
      <categories>
        <category>tech</category>
      </categories>
      <tags>
        <tag>couchdb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好文章]]></title>
    <url>%2F2017%2F02%2F15%2Fgoodarticle%2F</url>
    <content type="text"><![CDATA[1. 工具类 与Kindle电子书相关的工具软件 thx/RAP接口管理与部署 Insomnia 3.0 sublime text 3 package control的安装 如何利用Google成为一个更好的程序员 2. 开源框架 Redis 持久化和常见故障 《ZooKeeper官方文档》Zookeeper操作指南 善待Redis里的数据 Elasticsearch 权威指南（中文版） 最好的8个 Java RESTful 框架 10大Java开源中文分词器的使用方法和分词效果对比 MemCache超详细解读 Kafka剖析（一）：Kafka背景及架构介绍 java Jedis连接池的使用 搜索引擎选择： Elasticsearch与Solr 3. 工作周边 显著提升程序员身心健康和工作效率的装备有哪些？ 我们为什么应该坚持写博客 4. 书籍推荐 你不得不读的书籍清单 5. 计算机知识 关于启用HTTPS的一些经验分享（二） 搭建自己的VPS服务器 献给初学者：谈谈如何学习Linux 程序员应该掌握的10个搜索技巧 十分钟搞清字符集和字符编码 二维码的生成细节和原理 HTTPS科普扫盲帖 github开wiki目录的chrome插件 化繁为简，如何向老婆解释MapReduce？ Multicast RESTful API 编写指南 6. java Java开发必会的Linux命令 Java日志记录的5条规则 深入理解 RESTful Api 架构 2015，我读过的那些书 Java内存分配和String类型的深度解析 Java HashMap工作原理及实现 ConurrentHashMap和Hashtable的区别 HashMap的工作原理 java中hashcode()和equals()的详解 浅谈Java中的hashcode方法 Java HashMap工作原理及实现 分类目录: NoSql Java集合总结之Collection整体框架 8张图理解Java Java 7 并发编程指南中文版 40个Java集合面试问题和答案 理解Java中的ThreadLocal 大神手把手教你Java性能优化-江南白衣（加强版） 7. linux 如何在 VPS 上搭建 VPN 来翻墙 Nmon 监控 Linux 的系统性能 Linux运维人员成长之路学习书籍推荐 利用 ssh 的用户配置文件 config 管理 ssh 会话 ssh_config 文件配置详解 8. 编程之外 前端大牛得到的最佳职业生涯建议 一个老DBA的自白 Java工程师成神之路 eclipse全面提速 远程工作之个人效率篇 我的学习、归纳方法 “硅谷最重要的文件”:《纸牌屋》制作商Neflix公司内部PPT 关于团队管理的一些思考 个人知识管理的方法 码农和英语 给编程生涯充电的10本书]]></content>
      <categories>
        <category>enshrine</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux学习]]></title>
    <url>%2F2017%2F02%2F15%2Flinux%2F</url>
    <content type="text"><![CDATA[1. 个人 linux相关软件安装 linux使用过的命令记录 linux遇到过的问题 2. 收藏 Nmon 监控 Linux 的系统性能 Linux运维人员成长之路学习书籍推荐 Java开发必会的Linux命令 献给初学者：谈谈如何学习Linux]]></content>
      <categories>
        <category>enshrine</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>